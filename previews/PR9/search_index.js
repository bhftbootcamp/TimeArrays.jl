var documenterSearchIndex = {"docs":
[{"location":"pages/resample/#resample","page":"Resample","title":"Resample","text":"","category":"section"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"Let's assume that you have some time series with arbitrary timestamps and you need to bring the values to a new aligned grid with a fixed period in time. For example, like this:","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"<pre>\n\n value:         1.0   2.0         3.0               4.0   5.0   6.0   7.0\n grid:      - - X - - X - - - - - X - - - - - - - - X - - X - - X - - X - -\n time:          1     2           4                 7     8     9     10\n\n</pre>","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"To do this you will need a resampling method, which we will now look at in more detail. The resampling method can be broken down into four steps:","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"selecting the origin of the time grid.\ndividing the new grid into sub-intervals.\ndefining the parameters of these sub-intervals, such as the closed side and the label side.\nAggregation of values ​​falling into a new subinterval.","category":"page"},{"location":"pages/resample/#Origin-of-the-new-time-grid","page":"Resample","title":"Origin of the new time grid","text":"","category":"section"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"First you need to select the origin of the new grid:","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"ORIGIN_OF_WINDOW (default): Origin of coordinates for the corresponding time type (Beginning of the year for dates, zero for numbers).\nSTART_OF_WINDOW: The first timestamp in the current time series.\nEND_OF_WINDOW: The last timestamp in the current time series.","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"<pre>\n\n value:        1.0   2.0         3.0               4.0   5.0   6.0   7.0\n grid:    X - - X - - X - - - - - X - - - - - - - - X - - X - - X - - X - -\n time:    0     1     2           4                 7     8     9     10\n          ^     ^                                                     ^\n          |     |                                                     |\n          |     START_OF_WINDOW                           END_OF_WINDOW\n          ORIGIN_OF_WINDOW (default)\n\n</pre>","category":"page"},{"location":"pages/resample/#Period-of-the-new-time-grid","page":"Resample","title":"Period of the new time grid","text":"","category":"section"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"Then, relative to the selected origin, a grid with a step of the specified period will be created","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"<pre>\n\n value:            1.0   2.0         3.0               4.0   5.0   6.0   7.0\n grid:        X - - X - - X - - - - - X - - - - - - - - X - - X - - X - - X - -\n time:        0     1     2           4                 7     8     9     10\n\n</pre>\n\n<pre>\n\n period = 2:  | - - - - - | - - - - - | - - - - - | - - - - - | - - - - - | - -\n              0           2           4           6           8           10\n\n period = 3:  | - - - - - - - - | - - - - - - - - | - - - - - - - - | - - - - -\n              0                 3                 6                 9\n              ^\n              |\n              ORIGIN_OF_WINDOW (default)\n\n</pre>\n\n<pre>\n\n period = 2:  - - - | - - - - - | - - - - - | - - - - - | - - - - - | - - - - - \n                    1           3           5           7           9           \n\n period = 3:  - - - | - - - - - - - - | - - - - - - - - | - - - - - - - - | - - \n                    1                 4                 7                 10\n                    ^\n                    |\n                    START_OF_WINDOW\n\n</pre>\n\n<pre>\n\n period = 2:  | - - - - - | - - - - - | - - - - - | - - - - - | - - - - - | - -\n              0           2           4           6           8           10\n\n period = 3:  - - - | - - - - - - - - | - - - - - - - - | - - - - - - - - | - - \n                    1                 4                 7                 10\n                                                                          ^\n                                                                          |\n                                                              END_OF_WINDOW\n\n</pre>","category":"page"},{"location":"pages/resample/#Parameters-of-sub-intervals","page":"Resample","title":"Parameters of sub-intervals","text":"","category":"section"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"Finally, it only remains to determine which side of the subintervals will be closed, as well as on which side the aggregation of the values ​​falling within the interval will occur. The following example shows how parameters CLOSED_LEFT and CLOSED_RIGHT, as well as LABEL_LEFT and LABEL_RIGHT, determine the behavior of the subintervals.","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"An example of the obtained sub-intervals with parameters origin = ORIGIN_OF_WINDOW and period = 2:","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"<pre>\n\n value:      1.0       2.0       3.0                       1.0       2.0       3.0\n grid:    - - X - - - - X - - - - X - -   ➤   - - | - - - - X - - - - | - - - - X - - - - | - -\n time:        1         2         3               0                   2                   4\n\n</pre>","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"Possible options for decomposing values ​​into new sub-intervals for subsequent aggregation:","category":"page"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"<table>\n  <tr>\n    <th></th>\n    <th align=center>CLOSED_LEFT (default)</th>\n    <th align=center>CLOSED_RIGHT</th>\n  </tr>\n  <tr>\n    <th>LABEL_LEFT<br>(default)</th>\n    <td>\n<pre>\n\n value:       1.0       2.0   3.0\n grid:   [ - - - - - )[ - - - - - )  \n time:    ⤷ 0          ⤷ 2 \n\n</pre>\n    </td>\n    <td>\n<pre>\n\n value:    1.0   2.0       3.0\n grid:   ( - - - - - ]( - - - - - ]  \n time:    ⤷ 0          ⤷ 2 \n\n</pre>\n    </td>\n  </tr>\n  <tr>\n    <th>LABEL_RIGHT</th>\n    <td>\n<pre>\n\n value:       1.0       2.0   3.0\n grid:   [ - - - - - )[ - - - - - )  \n time:            2 ⤶          4 ⤶ \n\n</pre>\n    </td>\n    <td>\n<pre>\n\n value:    1.0   2.0       3.0\n grid:   ( - - - - - ]( - - - - - ]  \n time:            2 ⤶          4 ⤶\n\n</pre>\n    </td>\n  </tr>\n</table>","category":"page"},{"location":"pages/resample/#Values-aggregation","page":"Resample","title":"Values aggregation","text":"","category":"section"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"Finally, the old values ​​that fall into the new subinterval can be aggregated by applying some function, such as sum, maximum, minimum, mean, median, etc.","category":"page"},{"location":"pages/resample/#API","page":"Resample","title":"API","text":"","category":"section"},{"location":"pages/resample/","page":"Resample","title":"Resample","text":"ta_resample","category":"page"},{"location":"pages/resample/#TimeArrays.ta_resample","page":"Resample","title":"TimeArrays.ta_resample","text":"ta_resample(f::Function, t_array::TimeArray{T,V}, period::PeriodLike; kw...) -> TimeArray\n\nBrings the values of t_array to a new time grid with new period using the function f on intermediate values of the old grid.\n\nFunction f must accept a vector with elements of type V as input and return a new value, which will be assigned to the corresponding timestamp of the each window. If it is impossible to calculate a new value based on the received vector (for example, the vector is empty), then the NaN value or an equivalent value (for custom types) must be returned.\n\nKeyword arguments\n\norigin::ORIGIN_TYPE = ORIGIN_OF_WINDOW: Start of new grid (Possible values: ORIGIN_OF_WINDOW, START_OF_WINDOW, END_OF_WINDOW).\nclosed::CLOSED_SIDE = CLOSED_LEFT: Closed side of the half-open subintervals of new grid (Possible values: CLOSED_LEFT, CLOSED_RIGHT).\nlabel::LABEL_SIDE = LABEL_LEFT: Label side of the subintervals of new grid (Possible values: LABEL_LEFT, LABEL_RIGHT).\n\nFor more information see resample section.\n\nExamples\n\njulia> t_array = TimeArray{Int64,Int64}([(i, i) for i in 3:13])\n11-element TimeArray{Int64, Int64}:\n TimeTick(3, 3)\n TimeTick(4, 4)\n TimeTick(5, 5)\n TimeTick(6, 6)\n TimeTick(7, 7)\n TimeTick(8, 8)\n TimeTick(9, 9)\n TimeTick(10, 10)\n TimeTick(11, 11)\n TimeTick(12, 12)\n TimeTick(13, 13)\n\njulia> ta_resample(sum, t_array, 4, closed = CLOSED_LEFT, label = LABEL_LEFT)\n4-element TimeArray{Int64, Int64}:\n TimeTick(0, 3)\n TimeTick(4, 22)\n TimeTick(8, 38)\n TimeTick(12, 25)\n\njulia> ta_resample(sum, t_array, 4, closed = CLOSED_LEFT, label = LABEL_RIGHT)\n4-element TimeArray{Int64, Int64}:\n TimeTick(4, 3)\n TimeTick(8, 22)\n TimeTick(12, 38)\n TimeTick(16, 25)\n\njulia> ta_resample(sum, t_array, 4, closed = CLOSED_RIGHT, label = LABEL_LEFT)\n4-element TimeArray{Int64, Int64}:\n TimeTick(0, 7)\n TimeTick(4, 26)\n TimeTick(8, 42)\n TimeTick(12, 13)\n\njulia> ta_resample(sum, t_array, 4, closed = CLOSED_RIGHT, label = LABEL_RIGHT)\n4-element TimeArray{Int64, Int64}:\n TimeTick(4, 7)\n TimeTick(8, 26)\n TimeTick(12, 42)\n TimeTick(16, 13)\n\njulia> using Dates\n\njulia> t_array = TimeArray{DateTime,Float64}([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n           TimeTick(DateTime(\"2024-01-09\"), 4.0),\n           TimeTick(DateTime(\"2024-01-12\"), 5.0),\n           TimeTick(DateTime(\"2024-01-13\"), 6.0),\n           TimeTick(DateTime(\"2024-01-20\"), 7.0),\n       ]);\n\njulia> ta_resample(x -> isempty(x) ? NaN : maximum(x), t_array, Day(3))\n7-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 3.0)\n TimeTick(2024-01-04T00:00:00, NaN)\n TimeTick(2024-01-07T00:00:00, 4.0)\n TimeTick(2024-01-10T00:00:00, 5.0)\n TimeTick(2024-01-13T00:00:00, 6.0)\n TimeTick(2024-01-16T00:00:00, NaN)\n TimeTick(2024-01-19T00:00:00, 7.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/arithmetic/#Arithmetic","page":"Arithmetic","title":"Arithmetic","text":"","category":"section"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Time series support basic arithmetic operations, allowing you to perform the necessary calculations. However, it is worth noting that such operations are performed in a slightly different way than on ordinary arrays, in which elements identical by index or value are compared. In our implementation, time series values ​​are matched by the last known time value.","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"To better understand the idea of ​​time series matching, let's look at the following simple example of adding two time series:","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"julia> t_array1 = TimeArray([\n           TimeTick(1, 2.0),\n           TimeTick(3, 4.0),\n           TimeTick(7, 6.0),\n       ]);\n\njulia> t_array2 = TimeArray([\n           TimeTick(3, 3.0),\n           TimeTick(5, 5.0),\n       ]);","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Visually, these time series can be represented as follows:","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"<pre>\n\n time:   - - - 1 - - - - 2 - - - - 3 - - - - 4 - - - - 5 - - - - 6 - - - - 7 - - - >\n \n              2.0                 4.0                                     6.0\n t_array1:     ● - - - - - - - - - ● - - - - - - - - - - - - - - - - - - - ● - - - > \n \n t_array2:                         ● - - - - - - - - - ● - - - - - - - - - - - - - >\n                                  3.0                 5.0\n\n</pre>","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Let's apply the addition operation to them.","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"julia> t_array1 + t_array2\n4-element TimeArray{Int64, Float64}:\n TimeTick(1, NaN)\n TimeTick(3, 7.0)\n TimeTick(5, 9.0)\n TimeTick(7, 11.0)","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"The expected behavior will be as follows:","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"For the first timestamp 1 from the t_array1 there is no time value from the t_array2 one, so the resulting value of this timestamp will be 2.0 + NaN = NaN.\nThen for timestamp 3 in both arrays there are values ​​(4.0 and 3.0), so as a result of addition we get 7.0.\nAt timestamp 5 in the t_array2 a new value appears 5.0 for which in the t_array1 the current value will be 4.0. As a result we get 9.0.\nFinally, at timestamp 7 happens the opposite of the previous case.","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"<pre>\n\n time:     - - - 1 - - - - 2 - - - - 3 - - - - 4 - - - - 5 - - - - 6 - - - - 7 - - - >\n \n                2.0                 4.0﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉⤵                   6.0\n t_array1:       ● - - - - - - - - - ● - - - - - - - - - - - - - - - - - - - ● - - - >\n                 ┊                   ┊                   ┊                   ┊\n    +       [2.0 + NaN]         [4.0 + 3.0]         [4.0 + 5.0]         [6.0 + 5.0]\n                 ┊                   ┊                   ┊                   ┊\n t_array2:       X                   ● - - - - - - - - - ● - - - - - - - - - - - - - >\n                NaN                 3.0                 5.0 ﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍⤴\n \n result:         ● - - - - - - - - - ● - - - - - - - - - ● - - - - - - - - - ● - - - > \n                NaN                 7.0                 9.0                11.0\n\n</pre>","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Supported mathematical operations on time series:","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"between two TimeArrays:\n+: addition\n-: subtraction\n*: multiplication\n/: division\nbetween TimeArray and other values\n+: addition\n-: subtraction\n*: multiplication\n/: division\n^: exponentiation","category":"page"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"For more flexible arithmetic work on TimeArrays, you can use functions ta_mergewith and ta_merge.","category":"page"},{"location":"pages/arithmetic/#API","page":"Arithmetic","title":"API","text":"","category":"section"},{"location":"pages/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"ta_mergewith\nta_merge","category":"page"},{"location":"pages/arithmetic/#TimeArrays.ta_mergewith","page":"Arithmetic","title":"TimeArrays.ta_mergewith","text":"ta_mergewith(f, l_array::TimeArray, r_array::TimeArray; kw...) -> TimeArray\n\nCreates a new TimeArray object by applying a binary function f on elements of left and right TimeArrays. TimeArrays uses the following rules to establish corresponding elements:\n\nAn element of the first array is matched to the nearest smaller or equal element of the second array.\nIf there is no such element in the second array, then the resulting element will be NaN.\n\nKeyword arguments\n\nl_merge::Bool = true: Use left timestamps in resulting TimeArray.\nr_merge::Bool = true: Use right timestamps in resulting TimeArray.\npadding::Bool = true: Preserve first timestamps with NaN values.\n\nExamples\n\njulia> using Dates\n\njulia> t_left = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), 0.2),\n           TimeTick(DateTime(\"2024-01-05\"), 0.5),\n       ]);\n\njulia> t_right = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-05\"), 5.0),\n           TimeTick(DateTime(\"2024-01-07\"), 7.0),\n       ]);\n\njulia> ta_mergewith(+, t_left, t_right)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, NaN)\n TimeTick(2024-01-02T00:00:00, 1.2)\n TimeTick(2024-01-05T00:00:00, 5.5)\n TimeTick(2024-01-07T00:00:00, 7.5)\n\njulia> ta_mergewith(-, t_left, t_right; l_merge = false)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, NaN)\n TimeTick(2024-01-05T00:00:00, -4.5)\n TimeTick(2024-01-07T00:00:00, -6.5)\n\njulia> ta_mergewith(*, t_left, t_right, r_merge = false, padding = false)\n2-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, 0.2)\n TimeTick(2024-01-05T00:00:00, 2.5)\n\n\n\n\n\n","category":"function"},{"location":"pages/arithmetic/#TimeArrays.ta_merge","page":"Arithmetic","title":"TimeArrays.ta_merge","text":"ta_merge(f::Function, t_array::TimeArray, value) -> TimeArray\nta_merge(f::Function, value, t_array::TimeArray) -> TimeArray\n\nCreates a new TimeArray by applying a binary function f with value on elements of t_array.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-04\"), 3.0),\n           TimeTick(DateTime(\"2024-01-08\"), 6.0),\n       ]);\n\njulia> ta_merge(+, t_array, 2.0)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-03T00:00:00, 4.0)\n TimeTick(2024-01-04T00:00:00, 5.0)\n TimeTick(2024-01-08T00:00:00, 8.0)\n\njulia> ta_merge(/, 18.0, t_array)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-03T00:00:00, 9.0)\n TimeTick(2024-01-04T00:00:00, 6.0)\n TimeTick(2024-01-08T00:00:00, 3.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#Replace-and-Fill","page":"Replace & Fill","title":"Replace & Fill","text":"","category":"section"},{"location":"pages/array/","page":"Replace & Fill","title":"Replace & Fill","text":"replace\nappend!\nvcat\ncumsum\nta_backward_fill\nta_forward_fill\nta_linear_fill","category":"page"},{"location":"pages/array/#Base.replace","page":"Replace & Fill","title":"Base.replace","text":"replace(t_array::TimeArray, old_new::Pair...; [, count]) -> TimeArray\n\nReturn a copy of t_array which has all values of old replaced by new in accordance with old_new pair. If count is specified, then replace at most count occurrences in total.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n       ]);\n\njulia> replace(t_array, 1.0 => 10.0, 2.0 => -2.0)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 10.0)\n TimeTick(2024-01-02T00:00:00, -2.0)\n TimeTick(2024-01-03T00:00:00, 3.0)\n\n\n\n\n\nreplace(f::Function, t_array::TimeArray; [, count]) -> TimeArray\n\nReturn a new array where each element is the result of function f applied to elements of t_array. If count is specified, then replace at most count occurrences in total.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n       ]);\n\njulia> replace(x -> isodd(x) ? -x : x, t_array)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, -1.0)\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-03T00:00:00, -3.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#Base.append!","page":"Replace & Fill","title":"Base.append!","text":"append!(t_array::TimeArray, new_ticks::AbstractVector{TimeTick}) -> TimeArray\n\nAdd new values from items to new_ticks and sorts them by date in ascending order.\n\nwarning: Warning\nAvoid inserting data in small batches, as each call to the append method triggers sorting.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n       ]);\n\njulia> new_ticks = [\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n       ];\n\njulia> append!(t_array, new_ticks)\n6-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 1.0)\n TimeTick(2024-01-01T00:00:00, 1.0)\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-03T00:00:00, 3.0)\n TimeTick(2024-01-03T00:00:00, 3.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#Base.vcat","page":"Replace & Fill","title":"Base.vcat","text":"vcat(l_array::TimeArray, r_array::TimeArray) -> TimeArray\n\nConcatenates two TimeArray objects vertically.\n\nExamples\n\njulia> using Dates\n\njulia> t_array_1 = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n       ]);\n\njulia> t_array_2 = TimeArray([\n           TimeTick(DateTime(\"2024-01-04\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-01\"), 3.0),\n       ]);\n\njulia> vcat(t_array_1, t_array_2)\n6-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 1.0)\n TimeTick(2024-01-01T00:00:00, 3.0)\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-03T00:00:00, 3.0)\n TimeTick(2024-01-04T00:00:00, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#Base.cumsum","page":"Replace & Fill","title":"Base.cumsum","text":"cumsum(t_array::TimeArray; kw...) -> TimeArray\n\nCumulative sum along the TimeTick values.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), 3.0),\n       ]);\n\njulia> cumsum(t_array)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 1.0)\n TimeTick(2024-01-02T00:00:00, 3.0)\n TimeTick(2024-01-03T00:00:00, 6.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#TimeArrays.ta_backward_fill","page":"Replace & Fill","title":"TimeArrays.ta_backward_fill","text":"ta_backward_fill([, pattern::Function], t_array::TimeArray) -> TimeArray\n\nReturn an array where elements that match pattern are replaced by nearest previous non-pattern value in t_array. By default pattern is isnan function.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-03\"), 1.0),\n           TimeTick(DateTime(\"2024-01-07\"), NaN),\n           TimeTick(DateTime(\"2024-01-09\"), NaN),\n           TimeTick(DateTime(\"2024-01-10\"), 5.0),\n       ]);\n\njulia> ta_backward_fill(t_array)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-03T00:00:00, 1.0)\n TimeTick(2024-01-07T00:00:00, 1.0)\n TimeTick(2024-01-09T00:00:00, 1.0)\n TimeTick(2024-01-10T00:00:00, 5.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#TimeArrays.ta_forward_fill","page":"Replace & Fill","title":"TimeArrays.ta_forward_fill","text":"ta_forward_fill([, pattern::Function], t_array::TimeArray) -> TimeArray\n\nReturn an array where elements that match pattern are replaced by nearest next non-pattern value in t_array. By default pattern is isnan function.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 2.0),\n           TimeTick(DateTime(\"2024-01-03\"), NaN),\n           TimeTick(DateTime(\"2024-01-04\"), NaN),\n           TimeTick(DateTime(\"2024-01-08\"), 7.0),\n       ]);\n\njulia> ta_forward_fill(t_array)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 2.0)\n TimeTick(2024-01-03T00:00:00, 7.0)\n TimeTick(2024-01-04T00:00:00, 7.0)\n TimeTick(2024-01-08T00:00:00, 7.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/array/#TimeArrays.ta_linear_fill","page":"Replace & Fill","title":"TimeArrays.ta_linear_fill","text":"ta_linear_fill([, pattern::Function], t_array::TimeArray) -> TimeArray\n\nReturn an array where elements that match pattern are replaced by linear interpolation between nearest not-pattern values in t_array. By default pattern is isnan function.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), 2.0),\n           TimeTick(DateTime(\"2024-01-04\"), NaN),\n           TimeTick(DateTime(\"2024-01-06\"), NaN),\n           TimeTick(DateTime(\"2024-01-08\"), 8.0),\n       ]);\n\njulia> ta_linear_fill(t_array)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-04T00:00:00, 4.0)\n TimeTick(2024-01-06T00:00:00, 6.0)\n TimeTick(2024-01-08T00:00:00, 8.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/rolling/#Rolling-window","page":"Rolling window","title":"Rolling window","text":"","category":"section"},{"location":"pages/rolling/","page":"Rolling window","title":"Rolling window","text":"ta_rolling\nta_sma\nta_wma\nta_ema\nta_lag\nta_lead","category":"page"},{"location":"pages/rolling/#TimeArrays.ta_rolling","page":"Rolling window","title":"TimeArrays.ta_rolling","text":"ta_rolling(f::Function, t_array::TimeArray, n::Int; kw...) -> TimeArray\n\nApplies function f in a sliding window with window size n to the elements of t_array. Function f must accept a vector with elements of type V as input and return a new value, which will be assigned to the corresponding timestamp of each window.\n\nKeyword arguments\n\nobservations::Integer = n: Number of observations in the rolling window to calculate the value (otherwise NaN).\n\nFunction signature:\n\nf(x::AbstractVector{V})::Any = ...\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-04\"), 3.0),\n           TimeTick(DateTime(\"2024-01-07\"), 4.0),\n           TimeTick(DateTime(\"2024-01-09\"), 5.0),\n       ]);\n\njulia> ta_rolling(sum, t_array, 3)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, NaN)\n TimeTick(2024-01-04T00:00:00, 6.0)\n TimeTick(2024-01-07T00:00:00, 9.0)\n TimeTick(2024-01-09T00:00:00, 12.0)\n\njulia> ta_rolling(sum, t_array, 3; observations = 1)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 1.0)\n TimeTick(2024-01-03T00:00:00, 3.0)\n TimeTick(2024-01-04T00:00:00, 6.0)\n TimeTick(2024-01-07T00:00:00, 9.0)\n TimeTick(2024-01-09T00:00:00, 12.0)\n\n\n\n\n\n\nta_rolling(f::Function, t_array::TimeArray, p::Period; kw...) -> TimeArray\n\nApplies function f in a sliding window with window period p to the elements of t_array. Function f must accept a vector with elements of type V as input and return a new value, which will be assigned to the corresponding timestamp of each window.\n\nFunction signature:\n\nf(x::AbstractVector{V})::Any = ...\n\nKeyword arguments\n\nobservations::Integer = 1: Number of observations in the rolling window to calculate the value (otherwise NaN).\n\nnote: Note\nThe first elements of the t_array during period p will always be replaced by NaN values (not enough elements in the window).\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-01\"), 1.0),\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-04\"), 3.0),\n           TimeTick(DateTime(\"2024-01-07\"), 4.0),\n           TimeTick(DateTime(\"2024-01-09\"), 5.0),\n       ]);\n\njulia> ta_rolling(sum, t_array, Day(3))\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, 3.0)\n TimeTick(2024-01-04T00:00:00, 5.0)\n TimeTick(2024-01-07T00:00:00, 4.0)\n TimeTick(2024-01-09T00:00:00, 9.0)\n\njulia> ta_rolling(sum, t_array, Day(3); observations = 2)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, 3.0)\n TimeTick(2024-01-04T00:00:00, 5.0)\n TimeTick(2024-01-07T00:00:00, NaN)\n TimeTick(2024-01-09T00:00:00, 9.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/rolling/#TimeArrays.ta_sma","page":"Rolling window","title":"TimeArrays.ta_sma","text":"ta_sma(t_array::TimeArray, n::Integer; kw...) -> TimeArray\nta_sma(t_array::TimeArray, p::Period; kw...) -> TimeArray\n\nApplies Simple Moving Average algorithm with window size n or period p to the elements of t_array.\n\nKeyword arguments\n\nSee ta_rolling for more information.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), 1.0),\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-05\"), 3.0),\n           TimeTick(DateTime(\"2024-01-06\"), 4.0),\n           TimeTick(DateTime(\"2024-01-09\"), 5.0),\n       ]);\n\njulia> ta_sma(t_array, 2)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, 1.5)\n TimeTick(2024-01-05T00:00:00, 2.5)\n TimeTick(2024-01-06T00:00:00, 3.5)\n TimeTick(2024-01-09T00:00:00, 4.5)\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), 1.0),\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-05\"), 3.0),\n           TimeTick(DateTime(\"2024-01-06\"), 4.0),\n           TimeTick(DateTime(\"2024-01-09\"), 5.0),\n       ]);\n\njulia> ta_sma(t_array, Day(3))\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, 1.5)\n TimeTick(2024-01-05T00:00:00, 2.5)\n TimeTick(2024-01-06T00:00:00, 3.5)\n TimeTick(2024-01-09T00:00:00, 5.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/rolling/#TimeArrays.ta_wma","page":"Rolling window","title":"TimeArrays.ta_wma","text":"ta_wma(t_array::TimeArray, n::Integer; kw...) -> TimeArray\nta_wma(t_array::TimeArray, p::Period; kw...) -> TimeArray\n\nApplies Weighted Moving Average algorithm with window size n or period p to the elements of t_array.\n\nKeyword arguments\n\nSee ta_rolling for more information.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), 1.0),\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-05\"), 3.0),\n           TimeTick(DateTime(\"2024-01-06\"), 4.0),\n           TimeTick(DateTime(\"2024-01-09\"), 5.0),\n       ]);\n\njulia> ta_wma(t_array, 3)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, NaN)\n TimeTick(2024-01-05T00:00:00, 2.333333333333333)\n TimeTick(2024-01-06T00:00:00, 3.333333333333333)\n TimeTick(2024-01-09T00:00:00, 4.333333333333333)\n\njulia> ta_wma(t_array, Day(3); observations = 2)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, 1.6666666666666665)\n TimeTick(2024-01-05T00:00:00, 2.6666666666666665)\n TimeTick(2024-01-06T00:00:00, 3.6666666666666665)\n TimeTick(2024-01-09T00:00:00, NaN)\n\n\n\n\n\n","category":"function"},{"location":"pages/rolling/#TimeArrays.ta_ema","page":"Rolling window","title":"TimeArrays.ta_ema","text":"ta_ema(t_array::TimeArray, window::Integer) -> TimeArray\n\nApplies Exponential Moving Average algorithm with window size n to the elements of t_array.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), 1.0),\n           TimeTick(DateTime(\"2024-01-03\"), 2.0),\n           TimeTick(DateTime(\"2024-01-05\"), 3.0),\n           TimeTick(DateTime(\"2024-01-06\"), 4.0),\n           TimeTick(DateTime(\"2024-01-09\"), 5.0),\n       ]);\n\njulia> ta_ema(t_array, 3)\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, 1.0)\n TimeTick(2024-01-03T00:00:00, 1.5)\n TimeTick(2024-01-05T00:00:00, 2.25)\n TimeTick(2024-01-06T00:00:00, 3.125)\n TimeTick(2024-01-09T00:00:00, 4.0625)\n\n\n\n\n\n","category":"function"},{"location":"pages/rolling/#TimeArrays.ta_lag","page":"Rolling window","title":"TimeArrays.ta_lag","text":"ta_lag(t_array::TimeArray, n::Integer) -> TimeArray\n\nShifts the values of t_array elements by n positions forward. Displaced elements that remain without a value are set to NaN.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-03-01\"), 1.0),\n           TimeTick(DateTime(\"2024-03-02\"), 2.0),\n           TimeTick(DateTime(\"2024-03-03\"), 3.0),\n           TimeTick(DateTime(\"2024-03-04\"), 4.0),\n       ]);\n\njulia> ta_lag(t_array, 2)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-03-01T00:00:00, NaN)\n TimeTick(2024-03-02T00:00:00, NaN)\n TimeTick(2024-03-03T00:00:00, 1.0)\n TimeTick(2024-03-04T00:00:00, 2.0)\n\n\n\n\n\n","category":"function"},{"location":"pages/rolling/#TimeArrays.ta_lead","page":"Rolling window","title":"TimeArrays.ta_lead","text":"ta_lead(t_array::TimeArray{T,V}, n::Integer) -> TimeArray\n\nShifts the values of t_array elements by n positions backward. Displaced elements that remain without a value are set to NaN.\n\nExamples\n\njulia> using Dates\n\njulia> t_array = TimeArray([\n           TimeTick(DateTime(\"2024-03-01\"), 1.0),\n           TimeTick(DateTime(\"2024-03-02\"), 2.0),\n           TimeTick(DateTime(\"2024-03-03\"), 3.0),\n           TimeTick(DateTime(\"2024-03-04\"), 4.0),\n       ]);\n\njulia> ta_lead(t_array, 2)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-03-01T00:00:00, 3.0)\n TimeTick(2024-03-02T00:00:00, 4.0)\n TimeTick(2024-03-03T00:00:00, NaN)\n TimeTick(2024-03-04T00:00:00, NaN)\n\n\n\n\n\n","category":"function"},{"location":"pages/interface/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"pages/interface/","page":"Types","title":"Types","text":"TimeArrays.TimeLike\nTimeArrays.PeriodLike","category":"page"},{"location":"pages/interface/#TimeArrays.TimeLike","page":"Types","title":"TimeArrays.TimeLike","text":"TimeLike <: Union{Dates.TimeType,Real}\n\nTimeArray's timestamp type that accepts Dates.TimeType and Real.\n\n\n\n\n\n","category":"type"},{"location":"pages/interface/#TimeArrays.PeriodLike","page":"Types","title":"TimeArrays.PeriodLike","text":"PeriodLike <: Union{Dates.Period,Real}\n\nTimeArray's period type that accepts Dates.Period and Real.\n\n\n\n\n\n","category":"type"},{"location":"pages/interface/#TimeTick","page":"Types","title":"TimeTick","text":"","category":"section"},{"location":"pages/interface/","page":"Types","title":"Types","text":"TimeArrays.AbstractTick\nTimeTick\nTimeTick(::Tuple)","category":"page"},{"location":"pages/interface/#TimeArrays.AbstractTick","page":"Types","title":"TimeArrays.AbstractTick","text":"AbstractTick{T,V}\n\nSupertype for TimeTick{T,V} with timestamp of type T and value of type V.\n\n\n\n\n\n","category":"type"},{"location":"pages/interface/#TimeArrays.TimeTick","page":"Types","title":"TimeArrays.TimeTick","text":"TimeTick{T,V} <: AbstractTick{T,V}\n\nA type describing a timestamp of type T<:TimeLike and its value of type V.\n\nFields\n\ntimestamp::T: The timestamp.\nvalue::V: The value.\n\nAccessors\n\nta_timestamp(x::TimeTick) -> x.timestamp\nta_value(x::TimeTick) -> x.value\n\n\n\n\n\n","category":"type"},{"location":"pages/interface/#TimeArrays.TimeTick-Tuple{Tuple}","page":"Types","title":"TimeArrays.TimeTick","text":"TimeTick{T,V}(timestamp::TimeLike, value)\nTimeTick(timestamp::T, value::V)\n\nConstructs a TimeTick object with the passed timestamp and value.\n\nExamples\n\njulia> using Dates\n\njulia> TimeTick{Date,Float64}(DateTime(\"2024-01-01T00:00:00\"), 100)\nTimeTick(2024-01-01, 100.0)\n\njulia> TimeTick(DateTime(\"2024-01-01T00:00:00\"), 100)\nTimeTick(2024-01-01T00:00:00, 100)\n\n\n\n\n\nTimeTick{T,V}(x::Tuple{TimeLike,Any})\nTimeTick(x::Tuple{T,V})\n\nConstructs a TimeTick object from tuple x which contains the timestamp and value.\n\nExamples\n\njulia> using Dates\n\njulia> TimeTick{Date,Float64}((DateTime(\"2024-01-01T00:00:00\"), 100))\nTimeTick(2024-01-01, 100.0)\n\njulia> TimeTick((DateTime(\"2024-01-01T00:00:00\"), 100))\nTimeTick(2024-01-01T00:00:00, 100)\n\n\n\n\n\nTimeTick{T,V}(x::NamedTuple{_,Tuple{TimeLike,Any}})\nTimeTick(x::NamedTuple{_,Tuple{TimeLike,Any}})\n\nConstructs a TimeTick object from named tuple x which contains the timestamp and value.\n\nExamples\n\njulia> using Dates\n\njulia> TimeTick{Date,Float64}((timestamp = DateTime(\"2024-01-01T00:00:00\"), value = 100))\nTimeTick(2024-01-01, 100.0)\n\njulia> TimeTick((timestamp = DateTime(\"2024-01-01T00:00:00\"), value = 100))\nTimeTick(2024-01-01T00:00:00, 100)\n\n\n\n\n\nTimeTick{T,V}(x::Pair{TimeLike,Number})\nTimeTick(x::Pair{T,V})\n\nConstructs a TimeTick object from pair x which contains the timestamp and value.\n\nExamples\n\njulia> using Dates\n\njulia> TimeTick{Date,Float64}(DateTime(\"2024-01-01T00:00:00\") => 100)\nTimeTick(2024-01-01, 100.0)\n\njulia> TimeTick(DateTime(\"2024-01-01T00:00:00\") => 100)\nTimeTick(2024-01-01T00:00:00, 100)\n\n\n\n\n\n","category":"method"},{"location":"pages/interface/#TimeArray","page":"Types","title":"TimeArray","text":"","category":"section"},{"location":"pages/interface/","page":"Types","title":"Types","text":"TimeArrays.AbstractTimeArray\nTimeArray\nTimeArray(::Vector)","category":"page"},{"location":"pages/interface/#TimeArrays.AbstractTimeArray","page":"Types","title":"TimeArrays.AbstractTimeArray","text":"AbstractTimeArray{T,V} <: AbstractVector{TimeTick{T,V}}\n\nSupertype for TimeArray{T,V} with timestamps of type T and values of type V.\n\n\n\n\n\n","category":"type"},{"location":"pages/interface/#TimeArrays.TimeArray","page":"Types","title":"TimeArrays.TimeArray","text":"TimeArray{T,V} <: AbstractTimeArray{T,V}\n\nType describing a time series with timestamps of type T and values of type V.\n\nFields\n\nvalues::Vector{TimeTick{T,V}}: Elements of a time series.\nlength::Int64: The length of the underlying array.\n\nAccessors\n\nta_values(x::TimeArray) -> x.values\n\n\n\n\n\n","category":"type"},{"location":"pages/interface/#TimeArrays.TimeArray-Tuple{Vector}","page":"Types","title":"TimeArrays.TimeArray","text":"TimeArray{T,V}(values::Vector{TimeTick})\nTimeArray(values::Vector{TimeTick{T,V}})\n\nCreates a TimeArray{T,V} object from values and sorts them by date in ascending order.\n\nExamples\n\njulia> using Dates\n\njulia> values = [\n           TimeTick(DateTime(\"2022-1-1T00:00:00\"), 3),\n           TimeTick(DateTime(\"2023-1-1T00:00:00\"), 1),\n           TimeTick(DateTime(\"2021-1-1T00:00:00\"), 2),\n       ];\n\njulia> TimeArray{Date,Float64}(values)\n3-element TimeArray{Date, Float64}:\n TimeTick(2021-01-01, 2.0)\n TimeTick(2022-01-01, 3.0)\n TimeTick(2023-01-01, 1.0)\n\njulia> TimeArray(values)\n3-element TimeArray{DateTime, Int64}:\n TimeTick(2021-01-01T00:00:00, 2)\n TimeTick(2022-01-01T00:00:00, 3)\n TimeTick(2023-01-01T00:00:00, 1)\n\n\n\n\n\nTimeArray(values::Vector{Pair{T,V}})\nTimeArray(values::Vector{Tuple{TimeLike,Any}})\nTimeArray(values::Vector{NamedTuple{_,Tuple{T,V}}})\n\nCreates a TimeArray{T,V} object from values and sorts them by date in ascending order.\n\nExamples\n\njulia> using Dates\n\njulia> TimeArray([\n           DateTime(\"2024-01-02T00:00:00\") => 3,\n           DateTime(\"2024-01-03T00:00:00\") => 1,\n           DateTime(\"2024-01-01T00:00:00\") => 2,\n       ])\n3-element TimeArray{DateTime, Int64}:\n TimeTick(2024-01-01T00:00:00, 2)\n TimeTick(2024-01-02T00:00:00, 3)\n TimeTick(2024-01-03T00:00:00, 1)\n\njulia> TimeArray([\n           (DateTime(\"2024-01-02T00:00:00\"), 3),\n           (DateTime(\"2024-01-03T00:00:00\"), 1),\n           (DateTime(\"2024-01-01T00:00:00\"), 2),\n       ])\n3-element TimeArray{DateTime, Int64}:\n TimeTick(2024-01-01T00:00:00, 2)\n TimeTick(2024-01-02T00:00:00, 3)\n TimeTick(2024-01-03T00:00:00, 1)\n\njulia> TimeArray([\n           (time = DateTime(\"2024-01-02T00:00:00\"), value = 3),\n           (time = DateTime(\"2024-01-03T00:00:00\"), value = 1),\n           (time = DateTime(\"2024-01-01T00:00:00\"), value = 2),\n       ])\n3-element TimeArray{DateTime, Int64}:\n TimeTick(2024-01-01T00:00:00, 2)\n TimeTick(2024-01-02T00:00:00, 3)\n TimeTick(2024-01-03T00:00:00, 1)\n\n\n\n\n\nTimeArray(timestamps::Vector{TimeLike}, values::Vector{Any})\n\nCreates a TimeArray by \"zipping\" together elements of timestamps and values.\n\nExamples\n\njulia> using Dates\n\njulia> timestamps = [\n           DateTime(\"2024-01-02\"),\n           DateTime(\"2024-01-03\"),\n           DateTime(\"2024-01-01\"),\n       ];\n\njulia> values = [2.0, 1.0, 3.0];\n\njulia> TimeArray(timestamps, values)\n3-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, 3.0)\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-03T00:00:00, 1.0)\n\n\n\n\n\nTimeArray{T,V}(values::AbstractVector)\n\nCreates a TimeArrays{T,V} from a values that contains any elements that can be passed to TimeTick{T,V} constructors.\n\nwarning: Warning\nThis approach greatly reduces performance. Use at your own discretion.\n\nExamples\n\njulia> using Dates\n\njulia> values = [\n           TimeTick(Date(\"2024-01-02\"), 3.0),\n           (DateTime(\"2024-01-03\"), 1.0),\n           Date(\"2024-01-01\") => 2,\n       ];\n\njulia> TimeArray{Date,Int64}(values)\n3-element TimeArray{Date, Int64}:\n TimeTick(2024-01-01, 2)\n TimeTick(2024-01-02, 3)\n TimeTick(2024-01-03, 1)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"<img src=assets/animation_light.gif>","category":"page"},{"location":"#TimeArrays.jl","page":"Home","title":"TimeArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TimeArrays simplifies working with time series data. It offers features like basic math operations, sliding window techniques, data resampling, and handling of missing values.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install TimeArrays, simply use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add TimeArrays","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In this example we perform math operations on several sets of time series.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates\nusing TimeArrays\n\na = TimeArray{DateTime,Float64}([\n    TimeTick(DateTime(\"2024-01-01\"), 1.0),\n    TimeTick(DateTime(\"2024-01-02\"), 4.0),\n    TimeTick(DateTime(\"2024-01-05\"), 2.0),\n    TimeTick(DateTime(\"2024-01-07\"), 5.0),\n])\n\nb = TimeArray{DateTime,Float64}([\n    (DateTime(\"2024-01-02\"), 4.0),\n    (DateTime(\"2024-01-06\"), 2.0),\n    (DateTime(\"2024-01-10\"), 1.0),\n])\n\nc = TimeArray{DateTime,Float64}([\n    DateTime(\"2024-01-01\") => 2.0,\n    DateTime(\"2024-01-09\") => 5.0,\n    DateTime(\"2024-01-11\") => 4.0,\n])\n\njulia> 2(a * b) + b / c\n8-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-01T00:00:00, NaN)\n TimeTick(2024-01-02T00:00:00, 34.0)\n ⋮\n TimeTick(2024-01-11T00:00:00, 10.25)","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSince our implementation of arithmetic operations between elements of two TimeArray's is somewhat different from the usual work with arrays, a diagram is provided below that shows how exactly the elements of the time series are related to each other. For more information see arithmetic section in documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<pre>\n\n time:     - - - 1 - - - - 2 - - - - 3 - - - - 4 - - - - 5 - - - - 6 - - - - 7 - - - >\n \n                2.0                 4.0﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉﹉⤵                   6.0\n t_array1:       ● - - - - - - - - - ● - - - - - - - - - - - - - - - - - - - ● - - - >\n                 ┊                   ┊                   ┊                   ┊\n    +       [2.0 + NaN]         [4.0 + 3.0]         [4.0 + 5.0]         [6.0 + 5.0]\n                 ┊                   ┊                   ┊                   ┊\n t_array2:       X                   ● - - - - - - - - - ● - - - - - - - - - - - - - >\n                NaN                 3.0                 5.0 ﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍﹍⤴\n \n result:         ● - - - - - - - - - ● - - - - - - - - - ● - - - - - - - - - ● - - - > \n                NaN                 7.0                 9.0                11.0\n\n</pre>","category":"page"},{"location":"","page":"Home","title":"Home","text":"TimeArrays can also deal with missing values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates\nusing TimeArrays\n\nnan_values = TimeArray{DateTime,Float64}([\n    TimeTick(DateTime(\"2024-01-02\"), 2.0),\n    TimeTick(DateTime(\"2024-01-04\"), NaN),\n    TimeTick(DateTime(\"2024-01-06\"), NaN),\n    TimeTick(DateTime(\"2024-01-08\"), 8.0),\n])\n\njulia> ta_forward_fill(nan_values)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-04T00:00:00, 8.0)\n TimeTick(2024-01-06T00:00:00, 8.0)\n TimeTick(2024-01-08T00:00:00, 8.0)\n\njulia> ta_linear_fill(nan_values)\n4-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, 2.0)\n TimeTick(2024-01-04T00:00:00, 4.0)\n TimeTick(2024-01-06T00:00:00, 6.0)\n TimeTick(2024-01-08T00:00:00, 8.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here we calculate the average price between two time series of high and low prices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TimeArrays\n\njulia> high_prices = ta_high_price_sample_data()\n2416-element TimeArray{DateTime, Float64}:\n TimeTick(2023-01-01T00:00:08.998, 0.2457)\n TimeTick(2023-01-01T00:00:43.315, 0.2458)\n ⋮\n TimeTick(2023-01-01T23:59:43.246, 0.25)\n\njulia> low_prices = ta_low_price_sample_data()\n2396-element TimeArray{DateTime, Float64}:\n TimeTick(2023-01-01T00:00:08.995, 0.2456)\n TimeTick(2023-01-01T00:00:43.319, 0.2457)\n ⋮\n TimeTick(2023-01-01T23:59:43.252, 0.2499)\n\njulia> (low_prices + high_prices) / 2\n3930-element TimeArray{DateTime, Float64}:\n TimeTick(2023-01-01T00:00:08.995, NaN)\n TimeTick(2023-01-01T00:00:08.998, 0.24565)\n ⋮\n TimeTick(2023-01-01T23:59:43.252, 0.24995)","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=right>\n<img src=assets/middle_price.png>\n\nVisualized with <a src=https://github.com/bhftbootcamp/LightweightCharts.jl>LightweightCharts.jl</a>.\n</div>\n\n<br>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can smooth the price data by using different Moving Average algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates\nusing TimeArrays\n\njulia> prices = ta_price_sample_data()\n7777-element TimeArray{DateTime, Float64}:\n TimeTick(2024-04-01T00:00:00.661, 0.6501)\n TimeTick(2024-04-01T00:05:57.481, 0.6505)\n ⋮\n TimeTick(2024-04-30T23:42:11.920, 0.4417)\n\njulia> sma_prices = ta_sma(prices, 20)\n7777-element TimeArray{DateTime, Float64}:\n TimeTick(2024-04-01T00:00:00.661, NaN)\n TimeTick(2024-04-01T00:05:57.481, NaN)\n ⋮\n TimeTick(2024-04-30T23:42:11.920, 0.4403)\n\njulia> wma_prices = ta_wma(prices, 20)\n7777-element TimeArray{DateTime, Float64}:\n TimeTick(2024-04-01T00:00:00.661, NaN)\n TimeTick(2024-04-01T00:05:57.481, NaN)\n ⋮\n TimeTick(2024-04-30T23:42:11.920, 0.4409)\n\njulia> ema_prices = ta_ema(prices, 20)\n7777-element TimeArray{DateTime, Float64}:\n TimeTick(2024-04-01T00:00:00.661, 0.6501)\n TimeTick(2024-04-01T00:05:57.481, 0.6501)\n ⋮\n TimeTick(2024-04-30T23:42:11.920, 0.4399)","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=right>\n<img src=assets/smoothed_prices.png>\n\nVisualized with <a src=https://github.com/bhftbootcamp/LightweightCharts.jl>LightweightCharts.jl</a>.\n</div>\n\n<br>","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also use custom types with TimeArrays. Below we convert prices into four-hour candlesticks using resampling.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Dates\nusing TimeArrays\n\nstruct OHLC\n    open::Float64\n    high::Float64\n    low::Float64\n    close::Float64\nend\n\nfunction ohlc(x::AbstractVector{<:Number})\n    return if isempty(x)\n        ta_nan(OHLC)\n    else\n        OHLC(x[1], maximum(x), minimum(x), x[end])\n    end\nend\n\nTimeArrays.ta_nan(::Type{OHLC}) = OHLC(NaN, NaN, NaN, NaN)\nTimeArrays.return_type(::typeof(ohlc), ::Type{<:Number}) = OHLC\n\njulia> prices = ta_price_sample_data()\n7777-element TimeArray{DateTime, Float64}:\n TimeTick(2024-04-01T00:00:00.661, 0.6501)\n TimeTick(2024-04-01T00:05:57.481, 0.6505)\n ⋮\n TimeTick(2024-04-30T23:42:11.920, 0.4417)\n\njulia> ta_resample(ohlc, prices, Hour(2); closed = CLOSED_RIGHT, label = LABEL_RIGHT)\n360-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-04-01T02:00:00, OHLC(0.6501, 0.6505, 0.6462, 0.6491))\n TimeTick(2024-04-01T04:00:00, OHLC(0.6478, 0.6480, 0.6443, 0.6452))\n ⋮\n TimeTick(2024-05-01T00:00:00, OHLC(0.4396, 0.4436, 0.4396, 0.4417))","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=right>\n<img src=assets/price_to_candles.png>\n\nVisualized with <a src=https://github.com/bhftbootcamp/LightweightCharts.jl>LightweightCharts.jl</a>.\n</div>","category":"page"},{"location":"pages/custom_types/#Custom-types","page":"Custom types","title":"Custom types","text":"","category":"section"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Not only Numbers, but also custom types can be used as time series values. However, it is worth noting that for the full correct use of custom types as TimeArrays values, it is necessary to define some methods, which will be listed below.","category":"page"},{"location":"pages/custom_types/#Required-methods","page":"Custom types","title":"Required methods","text":"","category":"section"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"To work with the main functions of the package, you need to define the following methods:","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Required methods Description\nBase.isnan(::Type{T}) Checks whether an object of type T is considered NaN\nTimeArray.ta_nan(::Type{T}) Returns an object of a custom type T that is treated as a NaN value.","category":"page"},{"location":"pages/custom_types/#Optional-methods","page":"Custom types","title":"Optional methods","text":"","category":"section"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"The following methods are useful to define for a custom type:","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Optional methods Description\nBase.isless(x::T, y::T) See isless.\nBase.isequal(x::T, y::T) See isequal.\nBase.:(==)(x::T, y::T) See ==.\nBase.:(+)(x::T, y::T) Addition between custom types.\nBase.:(-)(x::T, y::T) Subtraction between custom types.\nBase.:(*)(x::T, y::T) Multiplication between custom types.\nBase.:(/)(x::T, y::T) Division between custom types.\nBase.zero(::Type{T}) Returns an object of a custom type T that is treated as a zero value. For example, to use the sum method\nBase.one(::Type{T}) Returns an object of a custom type T that is treated as a one value. For example, to use the prod method","category":"page"},{"location":"pages/custom_types/#Example","page":"Custom types","title":"Example","text":"","category":"section"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Let's look at the necessary method overloads for our custom type that describes a candle:","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"struct OHLC\n    o::Float64\n    h::Float64\n    l::Float64\n    c::Float64\nend","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Next we will define the necessary methods:","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Base.zero(::Type{OHLC}) = OHLC(0.0, 0.0, 0.0, 0.0)\nBase.isnan(x::OHLC) = isnan(x.o) && isnan(x.h) && isnan(x.l) && isnan(x.c)\nTimeArrays.ta_nan(::Type{OHLC}) = OHLC(NaN, NaN, NaN, NaN)\n\nBase.isless(x::OHLC, y::OHLC) = isless(x.h, y.h)\n\nfunction Base.isequal(x::OHLC, y::OHLC)\n    return all([\n        isequal(x.o, y.o),\n        isequal(x.h, y.h),\n        isequal(x.l, y.l),\n        isequal(x.c, y.c),\n    ])\nend\n\nfunction Base.:(==)(x::OHLC, y::OHLC)\n    return all([\n        x.o == y.o,\n        x.h == y.h,\n        x.l == y.l,\n        x.c == y.c,\n    ])\nend\n\nBase.:+(left::OHLC, right::OHLC) = OHLC(left.o + right.o, left.h + right.h, left.l + right.l, left.c + right.c)\nBase.:-(left::OHLC, right::OHLC) = OHLC(left.o - right.o, left.h - right.h, left.l - right.l, left.c - right.c)\nBase.:*(left::OHLC, right::OHLC) = OHLC(left.o * right.o, left.h * right.h, left.l * right.l, left.c * right.c)\nBase.:*(left::Number, right::OHLC) = OHLC(left * right.o, left * right.h, left * right.l, left * right.c)\nBase.:*(left::OHLC, right::Number) = right * left\nBase.:/(left::Number, right::OHLC) = OHLC(left / right.o, left / right.h, left / right.l, left / right.c)\nBase.:/(left::OHLC, right::Number) = OHLC(left.o / right, left.h / right, left.l / right, left.c / right)","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"Now we can use OHLC as the time series value and use all the available functions:","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"julia> t_left = TimeArray([\n           TimeTick(DateTime(\"2024-1-1T1\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-1T2\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-1T3\"), OHLC(1, 2, 3, 4)),\n       ]);\n\njulia> t_right = TimeArray([\n           TimeTick(DateTime(\"2024-1-1T2\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-1T3\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-1T4\"), OHLC(1, 2, 3, 4)),\n       ]);\n\njulia> t_left + t_right\n4-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-01T01:00:00, OHLC(NaN, NaN, NaN, NaN))\n TimeTick(2024-01-01T02:00:00, OHLC(2.0, 4.0, 6.0, 8.0))\n TimeTick(2024-01-01T03:00:00, OHLC(2.0, 4.0, 6.0, 8.0))\n TimeTick(2024-01-01T04:00:00, OHLC(2.0, 4.0, 6.0, 8.0))","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"julia> t_nan = TimeArray([\n           TimeTick(DateTime(\"2024-01-02\"), OHLC(1, 1, 1, 1)),\n           TimeTick(DateTime(\"2024-01-03\"), OHLC(NaN, NaN, NaN, NaN)),\n           TimeTick(DateTime(\"2024-01-04\"), OHLC(NaN, NaN, NaN, NaN)),\n           TimeTick(DateTime(\"2024-01-05\"), OHLC(10, 10, 10, 10)),\n       ]);\n\njulia> ta_forward_fill(t_nan)\n4-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-02T00:00:00, OHLC(1.0, 1.0, 1.0, 1.0))\n TimeTick(2024-01-03T00:00:00, OHLC(10.0, 10.0, 10.0, 10.0))\n TimeTick(2024-01-04T00:00:00, OHLC(10.0, 10.0, 10.0, 10.0))\n TimeTick(2024-01-05T00:00:00, OHLC(10.0, 10.0, 10.0, 10.0))\n\njulia> ta_backward_fill(t_nan)\n4-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-02T00:00:00, OHLC(1.0, 1.0, 1.0, 1.0))\n TimeTick(2024-01-03T00:00:00, OHLC(1.0, 1.0, 1.0, 1.0))\n TimeTick(2024-01-04T00:00:00, OHLC(1.0, 1.0, 1.0, 1.0))\n TimeTick(2024-01-05T00:00:00, OHLC(10.0, 10.0, 10.0, 10.0))\n\njulia> ta_linear_fill(t_nan)\n4-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-02T00:00:00, OHLC(1.0, 1.0, 1.0, 1.0))\n TimeTick(2024-01-03T00:00:00, OHLC(4.0, 4.0, 4.0, 4.0))\n TimeTick(2024-01-04T00:00:00, OHLC(7.0, 7.0, 7.0, 7.0))\n TimeTick(2024-01-05T00:00:00, OHLC(10.0, 10.0, 10.0, 10.0))","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"julia> t_ohlc = TimeArray([\n           TimeTick(DateTime(\"2024-1-01\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-02\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-03\"), OHLC(1, 2, 3, 4)),\n           TimeTick(DateTime(\"2024-1-04\"), OHLC(1, 2, 3, 4)),\n       ]);\n\njulia> ta_lag(t_ohlc, 2)\n4-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-01T00:00:00, OHLC(NaN, NaN, NaN, NaN))\n TimeTick(2024-01-02T00:00:00, OHLC(NaN, NaN, NaN, NaN))\n TimeTick(2024-01-03T00:00:00, OHLC(1.0, 2.0, 3.0, 4.0))\n TimeTick(2024-01-04T00:00:00, OHLC(1.0, 2.0, 3.0, 4.0))\n\njulia> ta_rolling(sum, t_ohlc, 3)\n4-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-01T00:00:00, OHLC(NaN, NaN, NaN, NaN))\n TimeTick(2024-01-02T00:00:00, OHLC(NaN, NaN, NaN, NaN))\n TimeTick(2024-01-03T00:00:00, OHLC(3.0, 6.0, 9.0, 12.0))\n TimeTick(2024-01-04T00:00:00, OHLC(3.0, 6.0, 9.0, 12.0))\n\njulia> ta_resample(x -> isempty(x) ? ta_nan(x) : sum(x), t_ohlc, Day(2))\n2-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-01T00:00:00, OHLC(2.0, 4.0, 6.0, 8.0))\n TimeTick(2024-01-03T00:00:00, OHLC(2.0, 4.0, 6.0, 8.0))\n\njulia> ta_resample(sum, t_ohlc, Hour(12))\n7-element TimeArray{DateTime, OHLC}:\n TimeTick(2024-01-01T00:00:00, OHLC(1.0, 2.0, 3.0, 4.0))\n TimeTick(2024-01-01T12:00:00, OHLC(0.0, 0.0, 0.0, 0.0))\n TimeTick(2024-01-02T00:00:00, OHLC(1.0, 2.0, 3.0, 4.0))\n TimeTick(2024-01-02T12:00:00, OHLC(0.0, 0.0, 0.0, 0.0))\n TimeTick(2024-01-03T00:00:00, OHLC(1.0, 2.0, 3.0, 4.0))\n TimeTick(2024-01-03T12:00:00, OHLC(0.0, 0.0, 0.0, 0.0))\n TimeTick(2024-01-04T00:00:00, OHLC(1.0, 2.0, 3.0, 4.0))","category":"page"},{"location":"pages/custom_types/#Custom-methods","page":"Custom types","title":"Custom methods","text":"","category":"section"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"If you are going to use in ta_resample or ta_rolling some custom reducing function my_func(...) that takes a vector of elements of type V1 and returns a value of another type V2, then you will need to define a new method TimeArrays.return_type that will return type V2:","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"function my_func(x::AbstractVector{V1})::V2\n    return V2(...)\nend\n\nTimeArrays.return_type(::typeof(my_func), ::Type{V1}) = V2","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"This is needed to determine the type of the resulting TimeArray.","category":"page"},{"location":"pages/custom_types/#Example-2","page":"Custom types","title":"Example","text":"","category":"section"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"using Dates\nusing TimeArrays\n\nstruct Trade\n    price::Float64\n    volume::Float64\nend\n\nfunction w_avg(p::AbstractVector{Trade})\n    return sum(x -> x.price * x.volume, p) / sum(x -> x.volume, p)\nend\n\nTimeArrays.return_type(::typeof(w_avg), ::Type{Trade}) = Float64","category":"page"},{"location":"pages/custom_types/","page":"Custom types","title":"Custom types","text":"julia> t_array = TimeArray([\n          TimeTick(DateTime(\"2024-01-02\"), Trade(1.0, 10)),\n          TimeTick(DateTime(\"2024-01-03\"), Trade(2.0, 20)),\n          TimeTick(DateTime(\"2024-01-05\"), Trade(3.0, 30)),\n          TimeTick(DateTime(\"2024-01-06\"), Trade(4.0, 40)),\n          TimeTick(DateTime(\"2024-01-09\"), Trade(5.0, 50)),\n       ]);\n\njulia> ta_rolling(w_avg, t_array, Day(3))\n5-element TimeArray{DateTime, Float64}:\n TimeTick(2024-01-02T00:00:00, NaN)\n TimeTick(2024-01-03T00:00:00, 1.6666666666666667)\n TimeTick(2024-01-05T00:00:00, 2.6)\n TimeTick(2024-01-06T00:00:00, 3.5714285714285716)\n TimeTick(2024-01-09T00:00:00, 5.0)","category":"page"}]
}
